/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct EmailControllerApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> EmailControllerApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> EmailControllerApiClient<C> {
        EmailControllerApiClient {
            configuration,
        }
    }
}

pub trait EmailControllerApi {
    fn delete_all_emails(&self, ) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn delete_email(&self, email_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn download_attachment(&self, attachment_id: &str, email_id: &str, api_key: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn download_attachment_base64(&self, attachment_id: &str, email_id: &str) -> Box<dyn Future<Item = crate::models::DownloadAttachmentDto, Error = Error<serde_json::Value>>>;
    fn forward_email(&self, email_id: &str, forward_email_options: crate::models::ForwardEmailOptions) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_attachment_meta_data(&self, attachment_id: &str, email_id: &str) -> Box<dyn Future<Item = crate::models::AttachmentMetaData, Error = Error<serde_json::Value>>>;
    fn get_attachments(&self, email_id: &str) -> Box<dyn Future<Item = Vec<crate::models::AttachmentMetaData>, Error = Error<serde_json::Value>>>;
    fn get_email(&self, email_id: &str, decode: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>>;
    fn get_email_content_match(&self, email_id: &str, content_match_options: crate::models::ContentMatchOptions) -> Box<dyn Future<Item = crate::models::EmailContentMatchResult, Error = Error<serde_json::Value>>>;
    fn get_email_html(&self, email_id: &str, decode: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn get_email_html_query(&self, email_id: &str, html_selector: &str) -> Box<dyn Future<Item = crate::models::EmailTextLinesResult, Error = Error<serde_json::Value>>>;
    fn get_email_text_lines(&self, decode_html_entities: bool, email_id: &str) -> Box<dyn Future<Item = crate::models::EmailTextLinesResult, Error = Error<serde_json::Value>>>;
    fn get_emails_paginated(&self, inbox_id: Option<Vec<String>>, page: Option<i32>, size: Option<i32>, sort: Option<&str>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::PageEmailProjection, Error = Error<serde_json::Value>>>;
    fn get_raw_email_contents(&self, email_id: &str) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn get_raw_email_json(&self, email_id: &str) -> Box<dyn Future<Item = crate::models::RawEmailJson, Error = Error<serde_json::Value>>>;
    fn get_unread_email_count(&self, ) -> Box<dyn Future<Item = crate::models::UnreadCount, Error = Error<serde_json::Value>>>;
    fn reply_to_email(&self, email_id: &str, reply_to_email_options: crate::models::ReplyToEmailOptions) -> Box<dyn Future<Item = crate::models::SentEmailDto, Error = Error<serde_json::Value>>>;
    fn validate_email(&self, email_id: &str) -> Box<dyn Future<Item = crate::models::ValidationDto, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>EmailControllerApi for EmailControllerApiClient<C> {
    fn delete_all_emails(&self, ) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/emails".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn delete_email(&self, email_id: &str) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/emails/{emailId}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn download_attachment(&self, attachment_id: &str, email_id: &str, api_key: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/attachments/{attachmentId}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = api_key {
            req = req.with_query_param("apiKey".to_string(), s.to_string());
        }
        req = req.with_path_param("attachmentId".to_string(), attachment_id.to_string());
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn download_attachment_base64(&self, attachment_id: &str, email_id: &str) -> Box<dyn Future<Item = crate::models::DownloadAttachmentDto, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/attachments/{attachmentId}/base64".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("attachmentId".to_string(), attachment_id.to_string());
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn forward_email(&self, email_id: &str, forward_email_options: crate::models::ForwardEmailOptions) -> Box<dyn Future<Item = (), Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/emails/{emailId}/forward".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());
        req = req.with_body_param(forward_email_options);
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    fn get_attachment_meta_data(&self, attachment_id: &str, email_id: &str) -> Box<dyn Future<Item = crate::models::AttachmentMetaData, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/attachments/{attachmentId}/metadata".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("attachmentId".to_string(), attachment_id.to_string());
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_attachments(&self, email_id: &str) -> Box<dyn Future<Item = Vec<crate::models::AttachmentMetaData>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/attachments".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_email(&self, email_id: &str, decode: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = decode {
            req = req.with_query_param("decode".to_string(), s.to_string());
        }
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_email_content_match(&self, email_id: &str, content_match_options: crate::models::ContentMatchOptions) -> Box<dyn Future<Item = crate::models::EmailContentMatchResult, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/emails/{emailId}/contentMatch".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());
        req = req.with_body_param(content_match_options);

        req.execute(self.configuration.borrow())
    }

    fn get_email_html(&self, email_id: &str, decode: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/html".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = decode {
            req = req.with_query_param("decode".to_string(), s.to_string());
        }
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_email_html_query(&self, email_id: &str, html_selector: &str) -> Box<dyn Future<Item = crate::models::EmailTextLinesResult, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/emails/{emailId}/html-query".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());
        req = req.with_path_param("htmlSelector".to_string(), html_selector.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_email_text_lines(&self, decode_html_entities: bool, email_id: &str) -> Box<dyn Future<Item = crate::models::EmailTextLinesResult, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/emails/{emailId}/text".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("decodeHtmlEntities".to_string(), decode_html_entities.to_string());
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_emails_paginated(&self, inbox_id: Option<Vec<String>>, page: Option<i32>, size: Option<i32>, sort: Option<&str>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::PageEmailProjection, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = inbox_id {
            req = req.with_query_param("inboxId".to_string(), s.join(",").to_string());
        }
        if let Some(ref s) = page {
            req = req.with_query_param("page".to_string(), s.to_string());
        }
        if let Some(ref s) = size {
            req = req.with_query_param("size".to_string(), s.to_string());
        }
        if let Some(ref s) = sort {
            req = req.with_query_param("sort".to_string(), s.to_string());
        }
        if let Some(ref s) = unread_only {
            req = req.with_query_param("unreadOnly".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn get_raw_email_contents(&self, email_id: &str) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/raw".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_raw_email_json(&self, email_id: &str) -> Box<dyn Future<Item = crate::models::RawEmailJson, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/{emailId}/raw/json".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

    fn get_unread_email_count(&self, ) -> Box<dyn Future<Item = crate::models::UnreadCount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/emails/unreadCount".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;

        req.execute(self.configuration.borrow())
    }

    fn reply_to_email(&self, email_id: &str, reply_to_email_options: crate::models::ReplyToEmailOptions) -> Box<dyn Future<Item = crate::models::SentEmailDto, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/emails/{emailId}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());
        req = req.with_body_param(reply_to_email_options);

        req.execute(self.configuration.borrow())
    }

    fn validate_email(&self, email_id: &str) -> Box<dyn Future<Item = crate::models::ValidationDto, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/emails/{emailId}/validate".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_path_param("emailId".to_string(), email_id.to_string());

        req.execute(self.configuration.borrow())
    }

}
