/*
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct WaitForControllerApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> WaitForControllerApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> WaitForControllerApiClient<C> {
        WaitForControllerApiClient {
            configuration,
        }
    }
}

pub trait WaitForControllerApi {
    fn wait_for(&self, wait_for_conditions: Option<crate::models::WaitForConditions>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>>;
    fn wait_for_email_count(&self, count: Option<i32>, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>>;
    fn wait_for_latest_email(&self, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>>;
    fn wait_for_matching_email(&self, match_options: crate::models::MatchOptions, count: Option<i32>, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>>;
    fn wait_for_nth_email(&self, inbox_id: Option<&str>, index: Option<i32>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>WaitForControllerApi for WaitForControllerApiClient<C> {
    fn wait_for(&self, wait_for_conditions: Option<crate::models::WaitForConditions>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/waitFor".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        req = req.with_body_param(wait_for_conditions);

        req.execute(self.configuration.borrow())
    }

    fn wait_for_email_count(&self, count: Option<i32>, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/waitForEmailCount".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = count {
            req = req.with_query_param("count".to_string(), s.to_string());
        }
        if let Some(ref s) = inbox_id {
            req = req.with_query_param("inboxId".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout {
            req = req.with_query_param("timeout".to_string(), s.to_string());
        }
        if let Some(ref s) = unread_only {
            req = req.with_query_param("unreadOnly".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn wait_for_latest_email(&self, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/waitForLatestEmail".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = inbox_id {
            req = req.with_query_param("inboxId".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout {
            req = req.with_query_param("timeout".to_string(), s.to_string());
        }
        if let Some(ref s) = unread_only {
            req = req.with_query_param("unreadOnly".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn wait_for_matching_email(&self, match_options: crate::models::MatchOptions, count: Option<i32>, inbox_id: Option<&str>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = Vec<crate::models::EmailPreview>, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/waitForMatchingEmails".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = count {
            req = req.with_query_param("count".to_string(), s.to_string());
        }
        if let Some(ref s) = inbox_id {
            req = req.with_query_param("inboxId".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout {
            req = req.with_query_param("timeout".to_string(), s.to_string());
        }
        if let Some(ref s) = unread_only {
            req = req.with_query_param("unreadOnly".to_string(), s.to_string());
        }
        req = req.with_body_param(match_options);

        req.execute(self.configuration.borrow())
    }

    fn wait_for_nth_email(&self, inbox_id: Option<&str>, index: Option<i32>, timeout: Option<i64>, unread_only: Option<bool>) -> Box<dyn Future<Item = crate::models::Email, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/waitForNthEmail".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "x-api-key".to_owned(),
            }))
        ;
        if let Some(ref s) = inbox_id {
            req = req.with_query_param("inboxId".to_string(), s.to_string());
        }
        if let Some(ref s) = index {
            req = req.with_query_param("index".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout {
            req = req.with_query_param("timeout".to_string(), s.to_string());
        }
        if let Some(ref s) = unread_only {
            req = req.with_query_param("unreadOnly".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

}
